library(caret)
library(jsonlite)
library(doParallel)

train <- read.csv("train.csv")

power_basis <- function(x, d, q_1, q_2=0, point=1, start=0, stop=1){
  
  # x      <--  vector of observation
  # d      <--  degree of the polynomial
  # q_1    <--  number of knots before 'point'
  # q_2    <--  number of knots after 'point'
  # point  <--  point which divide 'start-stop' in two chuncks
  # start  <--  min value of the x support
  # stop   <--  max value of the x support
  
  # calculate the coordinate of the knots
  if (q_2==0){
    knots <- seq(from=start, to=stop, length=q_1+2)[-c(1,q_1+2)]
  }
  else{
    knots <- c(seq(from=start, to=point, length=q_1+2)[-c(1)], seq(from=point, to=stop, length=q_2+2)[-c(1,q_2+2)]) 
  }
  
  # compute the coefficients of the polynomial
  pol_1 <- poly(x, degree=d, simple=T, raw=T)
  
  # subtracts the knots values from each point
  pol_2 <- sapply(x, function(a) (a - knots))
  
  # set to 0 the values that were <0
  pol_2[pol_2 < 0] <- 0
  
  # raise all points to the power d
  pol_2 <- pol_2^d
  
  # combine it all into an array
  X <- cbind(rep(1, length(x)), pol_1, t(pol_2))
  
  return(X)
  
}

MAESummary <- function (data, lev = NULL, model = NULL) {
  out <- MAE(data$obs,data$pred, 
             na.rm = TRUE)  
  names(out) <- "MAE"
  out
}

ncv <- function(df, R, K, type){
  
  library(caret)
  
  # initialize progress bar
  pb <- txtProgressBar(min=0, max=R*K, style=3)
  
  # set.seed(seed)
  
  # df <-- dataset composed of the design matrix 'X' and the target 'y' as a last column
  # R  <-- number of repetitions
  # K  <-- number of folds
  
  # initialize the variables
  es     <- rep(NA, R*K)
  a_list <- rep(NA, R*K)
  b_list <- rep(NA, R*K)
  
  # loop trough the simulation size
  for (r in 1:R){
    
    # randomly assign points to folds I1,...,IK
    folds_id <- createFolds(1:nrow(df), k=K)
    folds_df <- lapply(folds_id, function (f) df[f, ])
    
    # loop trough the number of folds
    for (k in 1:K){
      
      # increment progress bar
      pos <- k + K*(r-1)
      setTxtProgressBar(pb, pos)
      
      # calculate inner cross-validation
      e_in <- icv(df=folds_df, k=k, type=type)
      
      # dataframe without the k-th fold
      df_sub <- data.frame(do.call(rbind, lapply(seq_along(folds_df)[-k], function(i) folds_df[[i]])))
      
      # fit the algorithm
      if (type=="MAE"){
        fit <- train(y ~ ., 
                     data = df_sub, 
                     method = "lm",
                     metric = "MAE",
                     trControl = trainControl(summaryFunction = MAESummary, method="none")) 
      }
      else if(type=="log"){
        fit <- lm(df_sub[,ncol(df_sub)] ~ ., df_sub[,-ncol(df_sub)])
      }
      
      # dataframe with only the k-th fold
      df_k <- data.frame(do.call(rbind, lapply(seq_along(folds_df)[k], function(i) folds_df[[i]])))
      
      # predict the labels for the k-th fold
      if (type=="MAE"){
        pred <- as.vector(predict(fit, newdata=df_k))
        y_true <- as.vector(df_k[,ncol(df_k)])
        e_out <- (y_true-pred)^2
      }
      else if(type=="log"){
        pred <- exp(as.vector(predict(fit, newdata=df_k)))
        y_true <- exp(as.vector(df_k[,ncol(df_k)]))
        e_out <- (y_true-pred)^2
      }
      
      # compute the square loss for each point
      a_list[pos] <- (mean(e_in) - mean(e_out))^2
      b_list[pos] <- var(e_out) / nrow(df_k)
      es[pos] <- mean(e_in)
      
    }
  }
  close(pb)
  
  return (cbind(es,a_list,b_list))
  
}

icv <- function(df, k_in, type){
  
  # df <-- dataset composed of the design matrix 'X' and the target 'y' as a last column without the k-th fold
  # K  <-- is already K-1
  
  # initialize the variable
  e_in <- 0
  
  # loop trough the number of folds
  for (k in 1:K){
    
    if (k != k_in){
      # dataframe without the k-th fold
      df_sub <- data.frame(do.call(rbind, lapply(seq_along(df)[-c(k,k_in)], function(i) df[[i]])))
      # fit the algorithm
      if (type=="MAE"){
        fit <- train(y ~ ., 
                     data = df_sub, 
                     method = "lm",
                     metric = "MAE",
                     trControl = trainControl(summaryFunction = MAESummary, method="none")) 
      }
      else if(type=="log"){
        fit <- lm(df_sub[,ncol(df_sub)] ~ ., df_sub[,-ncol(df_sub)])
      }
      
      # dataframe with only the k-th fold
      df_k <- data.frame(do.call(rbind, lapply(seq_along(df)[k], function(i) df[[i]])))
      
      # predict the labels for the k-th fold
      if (type=="MAE"){
        pred <- as.vector(predict(fit, newdata=df_k[,-ncol(df_k)]))
        y_true <- as.vector(df_k[, ncol(df_k)])
        e_in <- c(e_in, (y_true-pred)^2)
      }
      else if(type=="log"){
        pred <- exp(as.vector(predict(fit, newdata=df_k[,-ncol(df_k)])))
        y_true <- exp(as.vector(df_k[, ncol(df_k)]))
        e_in <- c(e_in, (y_true-pred)^2)
      }
    }
  }
  return (e_in[-1])
}

set.seed(69)

numWorkers <- detectCores()  
cl <- makeCluster(numWorkers)
registerDoParallel(cl)

R <- 100
K <- 5
d_vec <- 3
q_1_vec <- 3:6
q_2_vec <- 1:3
RMSE_matrix <- array(NA, dim = c(length(d_vec),length(q_1_vec),length(q_2_vec)))
ERR_matrix <- array(NA, dim = c(length(d_vec),length(q_1_vec),length(q_2_vec)))

suppressWarnings(
  for (d in d_vec){
    for (q_1 in q_1_vec){
      print(q_1)
      for (q_2 in q_2_vec){
        X <- data.frame(power_basis(train$x,d=d,q_1=q_1,q_2=q_2,point=0.45))
        X$y <- train$y
        #for_value <- ncv(df=X, R=R, type="MAE", K=K)
        for_value <- foreach(i=1:numWorkers, .combine=rbind) %dopar% ncv(df=X, R=as.integer(R/numWorkers), type="MAE", K=K)
        RMSE_matrix[d-min(d_vec)+1,q_1-min(q_1_vec)+1, q_2-min(q_2_vec)+1] <-  sqrt(abs(mean(for_value[,2])-mean(for_value[,3])))
        ERR_matrix[d-min(d_vec)+1,q_1-min(q_1_vec)+1, q_2-min(q_2_vec)+1] <- sqrt(abs(mean(for_value[,1])))
      }
    }
  }
)

best_RMSE <- which(RMSE_matrix==min(RMSE_matrix, na.rm = T), arr.ind=TRUE)

df <- data.frame(
  d = best_RMSE[1],
  q_1 = best_RMSE[2],
  q_2 = best_RMSE[3]
)

json_data <- toJSON(df)

write(json_data, "best.json")

stopCluster(cl)

aieie <- fromJSON("best.json")
df <- data.frame(
       d = c(1,2,3),
       q_1 = c(1,2,3),
       q_2 = c(1,2,3)
  )
