library(glmnet)
library(boot)
library(randomForest)
library(doParallel)

train <- read.csv("train_hw03.csv")
#test  <- read.csv("test_hw03.csv")

#train$y = ifelse(train$y=="autism", 1, 0)
#train$sex = ifelse(train$sex=="male", 1, 0)

#test$sex = ifelse(test$sex=="male", 1, 0)
N_ROIs <- 116
ROI_length <- 115

train_partial <- data.frame(matrix(ncol=N_ROIs, nrow=nrow(train)))
# col_names <- c(paste0("mean_ROI_", 1:N_ROIs), paste0("sd_ROI_", 1:N_ROIs))
col_names <- c(paste0("mean_ROI_", 1:N_ROIs))
colnames(train_partial) <- col_names

start <- 5

fun_apply <- function(x){
  return(median(scale(x)))
}

for (i in 1:(N_ROIs)){
  sub_set <- train[, start:(start+ROI_length-1)]
  ROIs_mean <- apply(sub_set, MARGIN=1, FUN=mean)
  #ROIs_sd <- apply(sub_set, MARGIN=1, FUN=sd)
  train_partial[, i] <- ROIs_mean
  #train_partial[, i+N_ROIs] <- ROIs_sd
  start <- start + ROI_length
}

train_partial$sex <- train$sex
train_partial$age <- train$age

to_del <- unique(which(is.na(train_partial), arr.ind = T)[,1])

# prova glm:
# matrice con i dati relativi a D_1, cioÃ¨ pazienti nel train
if (length(to_del)>0){
  data_d1 <- data.frame(train_partial[-to_del,][1:500,])
  data_d2 <- data.frame(train_partial[-to_del,][501:(600-length(to_del)),])
  data_d1$y <- train$y[-to_del][1:500]
  data_d2$y <- train$y[-to_del][501:(600-length(to_del))]
} else{
    data_d1 <- data.frame(train_partial[1:500,])
    data_d2 <- data.frame(train_partial[501:600,])
    data_d1$y <- train$y[1:500]
    data_d2$y <- train$y[501:600]
}

model_true <- cv.glmnet(as.matrix(data_d1[sd_mod[1:500]<2,-119]), 
                        as.factor(train$y[1:500][sd_mod[1:500]<2]),
                        alpha = 1,
                        family = "binomial")

lam <- model_true$lambda.min
#model_true <- glmnet(y ~ ., data_d1, alpha = 1, lambda = 0.1, family = "binomial")
sum(abs((as.numeric(predict(model_true, as.matrix(data_d1[sd_mod[1:500]<=2,-119]), type = "class"))-train$y[1:500][sd_mod[1:500]<2])))

# per ogni jth devo calcolare il model su D_1 con e senza j th

fun_dentro <- function(data, ind, feat, model_true, model_j){
  aieie <- data[ind,]
  true <- predict(model_true, 
                  as.matrix(aieie[,-119]),
                  type = "class")
  meno_j <- predict(model_j, 
                    as.matrix(aieie[,-c(feat,119)]), 
                    type = "class")
  return(sum(abs(as.numeric(as.matrix(aieie[,119]))-as.numeric(meno_j)))/sum(abs(as.numeric(as.matrix(aieie[,119]))-as.numeric(true))))
}  

### Random Forest

numWorkers <- detectCores()  
cl <- makeCluster(numWorkers)
registerDoParallel(cl)

rf <- foreach(ntree=rep(100000, numWorkers),
              .combine=randomForest::combine,
              .multicombine=TRUE, 
              .packages='randomForest') %dopar% {
                         randomForest(data_d1[sd_mod[1:500]<2,-119],
                                      as.factor(train$y[1:500][sd_mod[1:500]<2]), 
                                      ntree = ntree)
              }

stopCluster(cl)

sum(abs(as.numeric(rf$y)-as.numeric(rf$predicted)))
rf$importance[order(rf$importance,decreasing = T),]

primi_10 <- order(forest$importance, decreasing = T)[1:20]
#################
mod_for <- list()

for (i in 1:118){
  print(i)
  mod_for[[i]] <- glmnet(as.matrix(data_d1[,-c(i,119)]),
                         as.factor(train$y[-to_del][1:400]),
                         alpha = 1,
                         lambda = lam,
                         family = "binomial")
}

b <- list()
b_median <- rep(NA,118)

for (f in 1:118){
  print(f)
  b[[f]] <- boot(data_d2,
                 statistic = fun_dentro,
                 R = 400,
                 feat = f,
                 model_true = model_true,
                 model_j = mod_for[[f]], 
                 parallel = "multicore")
  b_median[f] <- median(b[[f]]$t)
  print(b_median[f])
}

ind_paper = b_median>1
sum(ind_paper)


model_only_ind <- cv.glmnet(as.matrix(data_d1[,ind_paper]), 
                            as.factor(train$y[-to_del][1:400]),
                            alpha = 1,
                            family = "binomial")

lam <- model_only_ind$lambda.min
#model_true <- glmnet(y ~ ., data_d1, alpha = 1, lambda = 0.1, family = "binomial")
sum(abs((as.numeric(predict(model_only_ind, as.matrix(data_d1[ind_paper]), type = "class"))-train$y[-to_del][1:400])))

